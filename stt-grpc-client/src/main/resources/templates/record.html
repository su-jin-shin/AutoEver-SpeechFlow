<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§ ì‹¤ì‹œê°„ ìŒì„± ë³€í™˜ (WAV ì €ì¥ & ì‹¤ì‹œê°„ STT)</title>
    <style>
        .recording-session {
            margin-bottom: 20px;
            padding-bottom: 10px;
        }

        .recording-session.completed {
            border-bottom: 2px solid #ddd;
        }

        .transcription-line {
            display: inline-block;
        }

        .transcription-line span {
            margin-right: 10px;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
<h1>ğŸ§ ì‹¤ì‹œê°„ ìŒì„± ë³€í™˜ (WAV ì €ì¥ & ì‹¤ì‹œê°„ STT)</h1>
<button id="start">ğŸ¤ Start Recording</button>
<button id="stop" disabled>ğŸ›‘ Stop Recording</button>

<div id="results-container"></div>

<script>
    let audioContext;
    let mediaStream;
    let audioNode;
    //let sampleRate = 44100;
    let socket;
    let interval;
    let audioChunks = []; //ë…¹ìŒ ë°ì´í„° ì €ì¥ìš© ë°°ì—´
    let customerId;

    document.getElementById("start").addEventListener("click", async () => {
        audioChunks = []; // ê¸°ì¡´ ë°ì´í„° ì´ˆê¸°í™”

        // ê¸°ì¡´ WebSocket ì¢…ë£Œ (ìˆë‹¤ë©´)
        if (socket && socket.readyState !== WebSocket.CLOSED) {
            socket.close();
        }

        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext();

        console.log("ë§ˆì´í¬ ì…ë ¥ ìƒ˜í”Œë ˆì´íŠ¸:", mediaStream.getTracks()[0].getSettings().sampleRate);
        console.log("ìë™ ì„¤ì •ëœ AudioContext ìƒ˜í”Œ ë ˆì´íŠ¸:", audioContext.sampleRate);

        await audioContext.audioWorklet.addModule("/audio-processor.js");
        const source = audioContext.createMediaStreamSource(mediaStream);
        audioNode = new AudioWorkletNode(audioContext, "audio-processor");

        customerId = crypto.randomUUID().split("-")[0];
        socket = new WebSocket("ws://localhost:8081/audio-stream");

        // ìƒˆë¡œìš´ ë…¹ìŒ íšŒì°¨ë¥¼ ìœ„í•œ div ìƒì„±
        let resultsContainer = document.getElementById("results-container");

        let recordingBlock = document.createElement("div");
        recordingBlock.classList.add("recording-session");
        resultsContainer.appendChild(recordingBlock);

        let title = document.createElement("h3");
        title.innerText = "ğŸ“ ë³€í™˜ëœ í…ìŠ¤íŠ¸";
        recordingBlock.appendChild(title);

        let transcriptionLine = document.createElement("p");
        transcriptionLine.classList.add("transcription-line");
        recordingBlock.appendChild(transcriptionLine);

        socket.onopen = () => {
            console.log("WebSocket ì—°ê²° ì„±ê³µ! ê³ ê° ID:", customerId);
            socket.send(JSON.stringify({ type: "auth", customerId }));
        };

        socket.onmessage = (event) => {
            console.log("ë°›ì€ ë°ì´í„°:", event.data);
            try {
                let message = JSON.parse(event.data);
                let text = message.text;
                console.log('ë³€í™˜ëœ í…ìŠ¤íŠ¸: ' + text);

                let textSpan = document.createElement("span");
                textSpan.innerHTML = `âœ”ï¸ ${text} `;
                transcriptionLine.appendChild(textSpan);
            } catch (error) {
                console.error("âš ï¸ JSON íŒŒì‹± ì‹¤íŒ¨, ì›ë³¸ ì¶œë ¥:", event.data);
            }
        };

        //ì—ëŸ¬ë¡œ ì¸í•´ WebSocketì´ ë‹«íˆë©´ì„œ ë©”ì‹œì§€ê°€ ë³´ë‚´ì§€ì§€ ì•ŠëŠ” ë¬¸ì œ -> ë¸Œë¼ìš°ì €ê°€ WebSocketì„ ê°•ì œ ì¢…ë£Œí•  ë•Œë„ stop ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆë„ë¡
        window.onbeforeunload = () => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: "stop", customerId }));
            }
        };

        socket.onclose = (event) => {
            if (event.code !== 1000) {  // ì •ìƒ ì¢…ë£Œ(1000)ê°€ ì•„ë‹ ë•Œë§Œ ì²˜ë¦¬
                console.error(`[ERROR] WebSocket ì—°ê²° ì¢…ë£Œë¨ (ì½”ë“œ: ${event.code}, ì›ì¸: ${event.reason})`);

                let errorBlock = document.createElement("div");
                errorBlock.style.color = "red";
                errorBlock.style.fontWeight = "bold";
                errorBlock.style.marginTop = "10px";
                errorBlock.innerHTML = `âŒ WebSocket ì—°ê²° ì¢…ë£Œë¨ (ì½”ë“œ: ${event.code}, ì›ì¸: ${event.reason})`;
                resultsContainer.appendChild(errorBlock);

                //socket.send(JSON.stringify({ type: "stop", customerId }));
                stopRecording();
            }
        };

        socket.onerror = (error) => {
            console.error("âš ï¸ WebSocket ì˜¤ë¥˜ ë°œìƒ:", error);
        };

        audioNode.port.onmessage = (event) => {
            if (event.data.type === "stop") {
                console.log("10ì´ˆ ë¬´ìŒ â†’ ìë™ ë…¹ìŒ ì¢…ë£Œ");
                socket.send(JSON.stringify({ type: "stop", customerId }));
                stopRecording();
            } else {
                let floatData = mergeAudioChunks(event.data);
                audioChunks.push(floatData);
                if (socket.readyState === WebSocket.OPEN) {
                    let int16Array = float32ToInt16(floatData);
                    socket.send(int16Array);
                }
            }
        };

        source.connect(audioNode);
        audioNode.connect(audioContext.destination);

        document.getElementById("start").disabled = true;
        document.getElementById("stop").disabled = false;
    });


    document.getElementById("stop").addEventListener("click", () => {
        stopRecording();  // STOP ë²„íŠ¼ í´ë¦­ ì‹œ ë…¹ìŒ ì¤‘ì§€
    });

    function float32ToInt16(float32Array) {
        let int16Array = new Int16Array(float32Array.length);
        for (let i = 0; i < float32Array.length; i++) {
            let sample = Math.max(-1, Math.min(1, float32Array[i]));
            int16Array[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        }
        return int16Array;
    }

    function mergeAudioChunks(chunks) {
        let totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        let mergedBuffer = new Float32Array(totalLength);
        let offset = 0;

        for (let chunk of chunks) {
            mergedBuffer.set(chunk, offset);
            offset += chunk.length;
        }

        return mergedBuffer;
    }

    function encodeWAV(audioChunks, sampleRate) {
        let bufferLength = audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
        let wavBuffer = new ArrayBuffer(44 + bufferLength * 2);
        let view = new DataView(wavBuffer);

        function writeString(offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function writeInt16(offset, value) {
            view.setInt16(offset, value, true);
        }

        writeString(0, "RIFF");
        view.setUint32(4, 36 + bufferLength * 2, true);
        writeString(8, "WAVE");
        writeString(12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(36, "data");
        view.setUint32(40, bufferLength * 2, true);

        let offset = 44;
        audioChunks.forEach(chunk => {
            for (let i = 0; i < chunk.length; i++) {
                let sample = Math.max(-1, Math.min(1, chunk[i]));
                let int16Sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(offset, int16Sample, true);
                offset += 2;
            }
        });

        return new Blob([view], { type: "audio/wav" });
    }

    function stopRecording() {
        console.log("ğŸ›‘ ë…¹ìŒ ì¤‘ì§€ë¨");

        if (audioNode) {
            audioNode.disconnect();
        }

        if (audioContext && audioContext.state !== "closed") {
            audioContext.close();
        }

        if (mediaStream) {
            mediaStream.getTracks().forEach(track => track.stop());
        }

        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.close();
        }

        if (audioChunks.length > 0) {
            //let wavBlob = encodeWAV(audioChunks, sampleRate);
            let wavBlob = encodeWAV(audioChunks, audioContext.sampleRate);
            let url = URL.createObjectURL(wavBlob);

            let now = new Date();
            now.setHours(now.getHours() + 9);

            let filename = `recorded_${customerId}_` +
                `${now.toISOString().slice(0, 10).replace(/-/g, "")}-` +
                `${now.toISOString().slice(11, 23).replace(/[:.]/g, "")}`;

            let resultsContainer = document.getElementById("results-container");
            let recordingBlocks = resultsContainer.getElementsByClassName("recording-session");
            let lastRecordingBlock = recordingBlocks[recordingBlocks.length - 1];

            let downloadBlock = document.createElement("p");
            let downloadLink = document.createElement("a");
            downloadLink.href = url;
            downloadLink.download = filename + ".wav";
            downloadLink.innerHTML = "ğŸµ WAV ë‹¤ìš´ë¡œë“œ";
            downloadBlock.appendChild(downloadLink);
            lastRecordingBlock.appendChild(downloadBlock);
            lastRecordingBlock.classList.add("completed"); //Stop Recording í›„ ê°€ì¥ ë§ˆì§€ë§‰ ë¸”ë¡ì— border ì¶”ê°€
        }

        document.getElementById("start").disabled = false;
        document.getElementById("stop").disabled = true;
        audioChunks = [];
    }
</script>
</body>
</html>
